---
# title为文章的标题
title: 多线程基础
# cover为文章的首图和缩略图
# cover: http://img.blog.csdn.net/20150309140927553
# 作者信息，多作者则设置为数组
author: 
  nick: hanggle
  link: https://www.github.com/hanggle
# 如果文章为转载文章，需要多加文章出处项
#editor:
#  name: Minfive
#  link: https://www.github.com/Mrminfive
# 首页每篇文章的子标题
subtitle: 编程的正确方法是：首先要保证代码正确的运行，然后提高代码的速度。即便如此，最好也只是当性能测试结果和应用需求告诉你必须提高性能，以及测试结果表明这种优化在实际环境中确实能带来性能提升是，才进行优化。
tags: 
    - 基础
    - 多线程
categories: java
date: 2017-03-05 22:14:31
---

有三种方式可以解决多个线程同时访问同一个状态变量时会出现的问题。

* 不在线程之间共享该状态变量
* 将状态变量修改为不可变的变量
* 在访问状态变量是使用同步

编程的正确方法是：首先要保证代码正确的运行，然后提高代码的速度。即便如此，最好也只是当性能测试结果和应用需求告诉你必须提高性能，以及测试结果表明这种优化在实际环境中确实能带来性能提升是，才进行优化。

![image-20220131111435468](https://hanggle-blog.oss-cn-hangzhou.aliyuncs.com/article/image-20220131111435468.png)

> **1、新建状态（New）：**新创建了一个线程对象。
>
> **2、就绪状态（Runnable）：**线程对象创建后，其他线程调用了该对象的start()方法。该状态的线程位于可运行线程池中，变得可运行，等待获取CPU的使用权。
>
> **3、运行状态（Running）：**就绪状态的线程获取了CPU，执行程序代码。
>
> **4、阻塞状态（Blocked）：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：**
>
> **（一）、等待阻塞：运行的线程执行wait()方法，JVM会把该线程放入等待池中。(wait会释放持有的锁)**
>
> **（二）、同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中。**
>
> **（三）、其他阻塞：运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。（注意,sleep是不会释放持有的锁）**
>
> **5、死亡状态（Dead）：**线程执行完了或者因异常退出了run()方法，该线程结束生命周期。



